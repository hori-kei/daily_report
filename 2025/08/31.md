# 取り組んだ課題一覧

- 現場で使えるDjangoの教科書(第5章 tamplate_nameまで)

# わかったこと

- ビューはリクエストを受け取ってレスポンスオブジェクトを返す
- view.pyにビュー関数を定義し処理を記述する
    - 第一引数にrequestオブジェクト
    - 戻り値でresponseオブジェクトを返す
- クラスベースビューは再利用しやすいがコードの見通しが悪くなるという欠点があるが、Viewを直接継承するば解決する
- app_nameを記述する理由は複数のアプリに同じnameのURLパターンがあった場合に区別するため
    - app_nameはアプリ側のurls.py二記述
    - app_nameはただのモジュール変数だが名前空間を作る
    - DjangoはURLの逆引きを行うときにapp_name_nameの形式で使う名前空間を探すためモジュール変数のapp_nameをapplication_nameなどの違う名前にはできない。
        - なぜならDjangoの内部処理で、「app_name という名前の変数を探す」ように実装されているから
- as_view()はクラスで定義したビューを関数ビューとして扱えるようにするためのクラスメソッドでDjangoのディスパッチャは関数形式のビューじゃないと扱えないから。
- 基本汎用ビューであるTemplateViewはテンプレートを表示することだけに特化したビュークラス。
- template_nameはDjango内部で参照されている特別なクラス変数なので別名にするとまったく機能しない。
- get_context_data()メソッドとはテンプレートに渡すコンテキストをカスタマイズするためのメソッドでcontext = super().get_context_data(**kwargs)のように親クラスをオーバーライドした後に辞書になにか新しい変数定義などを追加する。
- **kwargsはキーワード引数(name=”Alison”, age=20)を辞書({name: “Alison”, age: 20})に変換する

# 次やること

- 現場で使えるDjangoの教科書(第5章 get_context_dataから)

# 感じたこと

- クラスベースだと内部の挙動がわかりにくいな。。。

# 学習時間

-  2.0時間